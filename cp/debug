/*

Debugging Template.

This template provides functions for debugging things easily.

What it can print:
- Base types (int, char, bool, etc.)
- Pairs
- Containers (vector, set, map, array, pbds, etc.)
- Queue, Stack, Priority Queue

How to use:
You can copy/paste the template to the actual file
or use it as a header file like this:
```
#ifdef LOCAL
#include "algo/debug"
#else
#define dbg(...)
#endif
```
I use ifdef with a macro, LOCAL, to make it more efficient.
It makes my life so much easier with letting me not to comment out garbages before submitting

To print things out just call `dbg(x, y, z)` and it will produce the output as this:
x, y, z ==> (value of x), (value of y), (value of z)

Example:

Code:
```
int n = 5, m = 4;
vector<int> a{1, 2, 3};
pair<string, string> p{"hello", "world"};
map<int, int> mp;
mp[10] = 20, mp[20] = 30;

dbg(n, m);
dbg(a, p);
dbg(mp);
```
Output:
n, m ==> 5, 4
a, p ==> {1, 2, 3}, ["hello", "world"]
mp ==> {[10, 20], [20, 30]}

*/



// Helper part to distinguish containers from other types
template <typename T, typename = void> struct is_iterable : std::false_type {};
template <typename T>
struct is_iterable<T, std::void_t<decltype(std::begin(std::declval<T>())),
                                  decltype(std::end(std::declval<T>()))>>
    : std::true_type {};
template <typename T> constexpr bool is_iterable_v = is_iterable<T>::value;
template <typename T>
constexpr bool is_string_v = std::is_same_v<std::decay_t<T>, std::string>;

// Base types
template <typename T>
std::enable_if_t<!is_iterable_v<T> || is_string_v<T>> print(const T &x) {
  std::cerr << x;
}

// Pairs
template <typename A, typename B> void print(const std::pair<A, B> &p) {
  std::cerr << "[";
  print(p.first);
  std::cerr << ", ";
  print(p.second);
  std::cerr << "]";
}

// Containers
template <typename C>
std::enable_if_t<is_iterable_v<C> && !is_string_v<C>> print(const C &c) {
  std::cerr << "{";
  bool first = true;
  for (auto &&x : c) {
    if (!first)
      std::cerr << ", ";
    print(x);
    first = false;
  }
  std::cerr << "}";
}

// Queues
template <typename T> void print(std::queue<T> q) {
  std::cerr << "{";
  bool f = true;
  while (!q.empty()) {
    if (!f)
      std::cerr << ", ";
    print(q.front());
    q.pop();
    f = false;
  }
  std::cerr << "}";
}

// Stacks
template <typename T> void print(std::stack<T> s) {
  std::cerr << "{";
  bool f = true;
  while (!s.empty()) {
    if (!f)
      std::cerr << ", ";
    print(s.top());
    s.pop();
    f = false;
  }
  std::cerr << "}";
}

// Priority queues
template <typename... Ts> void print(std::priority_queue<Ts...> pq) {
  std::cerr << "{";
  bool f = true;
  while (!pq.empty()) {
    if (!f)
      std::cerr << ", ";
    print(pq.top());
    pq.pop();
    f = false;
  }
  std::cerr << "}";
}

// Variadic print
template <typename T, typename... Ts> void print(const T &f, const Ts &...r) {
  print(f);
  if constexpr (sizeof...(r) > 0) {
    std::cerr << ", ";
    print(r...);
  }
}

// Core function
template <typename... Ts> inline void debug(const char *n, const Ts &...v) {
  if (std::strcmp(n, "0")) {
    std::cerr << n << " ==> ";
    print(v...);
  }
  std::cerr << '\n';
}

// The Macro
#define dbg(...) debug(#__VA_ARGS__, __VA_ARGS__)
